命令
ロード=LD（LoaD）命令 - 別のレジスタまたは主記憶からレジスタに値を引っ張ってくる
- オペランドのうち右のレジスタの内容を左レジスタに、または実効アドレスの示す内容を指定レジスタ内に移す
    - なおCASLIIではアドレスaddは10進定数または文字定数の前に等号をつけて記載でき、これをリテラルという
- フラグレジスタのOF（オーバフローフラグ）は0、SF（サインフラグ）は転送値が0以上なら0、負の値なら1が、ZF（ゼロフラグ）は転送値が0なら0、それ以外なら1が設定される
- LD GR0, GR1 - GR1の内容をGR0に転送
- LD GR1, LABEL1 - 主記憶のLABEL1の示す番地の内容をGR1に転送
- LD GR1, LABEL1 , GR2 - 主記憶の(LABEL1 + (GR2))の示す番地の内容をGR1に転送
- LD GR1, =10 - リテラル(10)10 = (00A0)16をGR1に転送する
- 文字定数定義時はアポストロフィをつけるが、2個以上の文字定数指定時は最初の一文字のみレジスタに格納される

ストア=ST(STore)命令 - 主記憶にレジスタ内容を落っことす
- CPU内レジスタの内容を指定実効アドレスに転送する
- フラグレジスタは変わらない
- ST GR1, LABEL1 - GR1の内容をLABEL1番地に転送
- ST GR0, LABEL1, GR1 - GR0の内容を(LABEL1 + (GR1))に転送

ロードアドレス=LAD(Load ADdress) - 実効アドレスをレジスタに設定する
- 主記憶の（ラベルがあればラベルの示す）指定絶対番地をレジスタに設定する
- 符号付き10進数も設定出来るのでレジスタの値を指定した値に出来る
- フラグレジスタは変わらない
- LAD GR0, LABEL1 - LABEL1の示す主記憶の絶対番地をGR0に設定する
    - プログラミング段階でどこにLABEL1が紐づくかはわからないため、LABEL1の場所を知るのに使う
- LAD GR0, 10 - GR0に10を設定する（絶対アドレス10を指定する）
- LAD GR1, 1, GR1 - GR1に1を足す（つまりGR1 = 1 + GR1）

実例 - A番地から始まる2語のデータを交換するプログラム

算術加算=ADDA(ADD Arithmetic) - 16ビットデータを符号付き数値（負数は2の補数）とみなし加算する（算術結果は-32768〜32767）
- レジスタ内容にレジスタ内容を足す、あるいはレジスタ＋主記憶アドレス内容をレジスタに加算する。主に数値計算で使う
- SF(サインフラグ)に結果格納レジスタの15ビット目が設定される
- ADDA GR0, GR1 - GR0の内容 + GR1の内容をGR0に格納する
- ADDA GR0, LABEL, GR1 - GR0の内容 + (LABEL + GR1)番地の内容をGR0に格納する
- ADDA GR1, =1 - GR1 + 1をGR1に格納する

論理加算=ADDL(ADD Logical) - 16ビットデータを符号なしの数値と見なして加算する（算術結果は0〜65535）
- 算術結果が32767を超えてもバグらない。主にアドレス算出で使う
- SF(サインフラグ)に結果格納レジスタの15ビット目が設定される
- (7FFF)16=(32767)10がGR1,GR2に入っている場合
    - ADDA GR1, GR2 - 32767 + 32767 = 不定（オーバーフローでバグる）
    - ADDL GR1, GR2 - 32767 + 32767 = 65534（バグらない。なお2進数表記だと符号ビットが1=負の値になるのでSFは1になる）

算術減算=SUBA(SUB Arithmetic) - 算術加算の減算版

論理減算=SUBL(SUB Logical) - 論理加算の減算版

論理演算について
- CASLIIの論理演算には論理積(AND)、論理和(OR)、排他的論理和(XOR)がある
- これらをMIL記号で雑に書いたのが以下。どの論理演算も入力A、Bの0、1の組み合わせから出力の0か1を決める。組み合わせ表を真理値表という

論理積=AND - 1語の論理積(入力が両方1で出力も1、それ以外0)を取る
- 特定ビットを取り出すのに使われる。取り出したいビットがあるところを1、それ以外を0にしたビットマスクと論理積を取る
- 結果の第15ビットがFR(フラグレジスタ)に格納される
- AND GR1, A - GR1とAの示す番地内容の論理積を取り、GR1に格納する
GR1 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 ＜マスク
lbA 1 0 1 1 0 0 1 1 1 0 1 1 1 0 1 1
res 0 0 0 0 0 0 0 0 1 0 1 1 1 0 1 1 ＜下位8ビットを取り出せた！
- AND GR0, GR1 GR0とGR1の論理積を取り、GR0に格納する
- AND GR0, =# 8000 - GR0とリテラル(8000)16の論理積を取り、GR0に格納する

論理和=OR - 1語の論理和(入力のどっちかが1で出力も1、両方0なら0)を取る
- ビット列を足すのによく使う
- 結果の第15ビットがFR(フラグレジスタ)に格納される
- OR GR1, A - GR1とAの示す番地内容の論理和を取り、GR1に格納する
GR1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 1
lbA 1 0 1 1 0 0 1 1 0 0 0 0 0 0 0 0
res 1 0 1 1 0 0 1 1 1 0 1 0 0 0 1 1
- OR GR0, GR1 - GR0とGR1の論理和をとり、GR0に格納する

排他的論理和=XOR - 1語の排他的論理和(入力が同じなら出力は0、違うなら1)を取る
- ビットを反転させたい時や比較するときに使う
- 結果の第15ビットがFR(フラグレジスタ)に格納される
- XOR GR1, A - GR1とAの示す番地内容の排他的論理和を取り、GR1に格納する
GR1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ＜マスク
lbA 1 0 1 1 0 0 1 1 0 0 1 1 0 1 0 1
res 0 1 0 0 1 1 0 0 1 1 0 0 1 0 1 0 ＜1と0がひっくり返った！
- XOR GR0, GR1 - GR0とGR1の排他的論理和を取り、GR0に格納する 

算術比較=CPA(ComPare Arithmetic) - 数値の算術比較(数値差範囲が-32768~32767)を行い、FRに結果に応じた値を設定する
- 数値1と数値2または実効アドレスを比較する
    - (r1)>(r2)ならSF=0,ZF=0
    - (r1)=(r2)ならSF=0,ZF=1
    - (r1)<(r2)ならSF=1,ZF=0
- CPA GR0, GR1 - (GR0)-(GR1)≧0の時にSF=0、(GR0)-(GR1)≦0の時にSF=1を設定する。等しいならZF=1、等しくないならZF=0が設定される
- CPA GR0, =100 - (GR0)-100≧0の時にSF=0、(GR0)-100≦0ならSF=1、等しいならZF=0
- CPA GR0, A, GR1 - (GR0)-(A+(GR1))≧0の時にSF=0、(GR0)-(A+(GR1))≦0ならSF=1、等しいならZF=0。A+(GR1)は実効アドレス、つまり(A+(GR1))番地の数値を指す

論理比較=CPL(ComPare Logical) - 数値の論理比較(オペランドの大小比較)を行い、FRに結果に応じた値を設定する
- 例えば(FFFF)16は算術だと(-1)10()、論理だと(65535)10となる。よってCPAだと(FFFF)<(0001) - SF=1、CPLだと(FFFF)>(0001) - SF=0。また数値が等しいならどっちもZF=1

算術左シフト=SLA(Shift Left Arithmetic) - 指定数値を実効アドレスのビット数だけ左にシフトする。空いたビットには0が入り、符号ビットは元の符号のままとなる
- OFはシフト時に最後にはみ出たビットの値になる
- これによって2の冪(べき)乗倍を計算できる。桁溢れしない限りでnビットを左シフトすると元の値を2のn乗できる
- SLA GR0, 3 - GR0の内容を3ビット左に算術シフトする
GR0 0000 0000 0000 1111 = (15)10
GR0 0000 0000 0111 1000 = (120)10 = 15*2^3
- SLA GR0, 0, GR1 - GR0の内容をGR1の内容分だけ左に算術シフトする
- ちなみにシフト命令は第2・第3オペランドで示されている実効アドレスをそのままずらす値にする。これは即値アドレス指定と呼び、LAD命令もこれにあたる。他は直接アドレス指定で、アドレスの中身をデータとして扱う

算術右シフト=SRA(Shift Right Arithmetic) - 指定数値を実効アドレスのビット数だけ右にシフトする。空いたビットには元のデータの符号ビットが入る、つまり符号は変わらない
- OFはシフト時に最後にはみ出たビットの値になる
- これによって元の数の除算ができる。nビット右シフトしたなら元の値を2^nで割れる
- SRA GR0, 2 - GR0の内容を符号を変えず2ビットシフトする
GR0 0000 0000 0000 1010 = (10)10
GR0 0000 0000 0000 0010 = (2)10 = 10/4 = 2(...2)

GR0 1000 1100 1111 0011 = (-29453)10
GR0 1110 0011 0011 1100 = (-7364)10 ※
    - ※ 商の-7363の余りを切り捨てた、つまり1小さい数にしたので(-7363)+(-1)=-7364
- SRA GR0, 0, GR1 - GR0の内容を符号を変えずGR1の内容分だけ右にシフトする

論理左シフト=SLL(Shift Left Logical) - 指定数値を実効アドレスのビット数だけ左にシフトする。空いたビットには0が入り、符号ビットも丸ごとシフトする
- OFはシフト時に最後にはみ出たビットの値になる
- SLL GR0, 5 - GR0の内容を5ビット左に論理シフトする
GR0 1101 0000 1010 0011
GR0 0001 0100 0110 0000
- SLL GR0, 0, GR1 - GR0の内容をGR1の内容分だけ左に論理シフトする

論理右シフト=SRL(Shift Right Logical) - 指定数値を実効アドレスのビット数だけ右にシフトする。空いたビットには0が入る、つまり負値は正値になる
- OFはシフト時に最後にはみ出たビットの値になる
- SRL GR0, 5 - GR0の内容を5ビット右に論理シフトする
GR0 1101 0000 1010 0011
GR0 0000 0110 1000 0101
- SRL GR0, 0, GR1 - GR0の内容をGR1の内容分だけ右に論理シフトする

正分岐=JPL(Jump on PLus) - SFが0かつZFが0なら指定アドレスに飛ぶ
  CPA GR0,=100 ;SF=0 or 1
  JPA A
  HOGEHOGE ;GR0<=100
A HUGAHUGA ;GR0>100
- GR0>100ならSF=0,ZF=0、GR0<100ならSF=1、GR0=100ならZF=1。SF=0かつZF=0なら指定アドレスに飛ぶので、つまり比較結果が(r1)>(r2)ならAに飛ぶ

負分岐=JMI(Jump on MInus) - SFが1なら指定アドレスに飛ぶ
CPA GR0,=10
JMI B
- GR0<10ならBに飛び、GR0=>ならスルーして次の命令に進む

非零分岐=JNZ(Jump on Non Zero) - ZFが0なら指定アドレスに飛ぶ
- ZFを0にするにはちょっとややこしく、
    - 比較命令(CPA,CPL)や算術演算命令(ADDA,ADDL,SUBA,SUBL)の第1第2オペランドが等しくない時
    - 論理演算(AND,OR,XOR)、シフト演算(SLA,SLL,SRA,SRL)で結果が0にならなかった時
- 以上で0になる
- ついでに(SLL GR0, 0)や(LD GR0, GR0)でGR0の内容を変えずにFRだけ変えられる

SRA GR0,1
JNZ A
- GR0を右に1ビットシフトし全てのビットが0になるとZFが1になり、JNZ命令はスルーされて次の命令に進む。0にならないならZFが0になりA番地に飛ぶ

零分岐=JZE(Jump on ZEro) - ZFが1なら指定アドレスに飛ぶ
- ZFを1にするには
    - 比較命令(CPA,CPL)や算術演算命令(ADDA,ADDL,SUBA,SUBL)の第1第2オペランドが等しい時
    - 論理演算(AND,OR,XOR)、シフト演算(SLA,SLL,SRA,SRL)で結果が0になった時
SLL GR0,1
JZE A
- GR0を1ビット左に論理シフトした時、全てのビットが0になったらZFが1になり、JZE命令でA番地に飛ぶ。ならなかったらZFは0でJZE命令はスルーされて次の命令に進む

オーバフロー分岐=JOV(Jump on OVerflow) - OFが1なら指定アドレスに飛ぶ
- OFは算術加算で結果が-32768~32767を超えたときやシフト演算命令で最後に出たビットが1の時に1になる
ADDA GR0,=30000
JOV  A
- GR0に30000を加算し、その結果が32767を超えたらOFが1になり、JOV命令でA番地に飛ぶ。加算結果が-32768~32767の範囲内なら次の結果に進む
SLL GR0,3
JOV A
- GR0を3ビット左シフトし最後にはみ出たビットが1、つまり元ビットの第13ビットが1ならOFが1になる

無条件分岐=JUMP(unconditional JUMP) - 何がなんだろうが指定アドレスに飛ぶ
- 無条件に指定アドレスに飛ぶ。制御が分かれて分岐先処理終了後、次の処理をしないようにするのに使う

繰り返し処理のコツ
- 繰り返し処理のトレース時は最初と最後だけうまくいってるかを調べればいい
- 初期値や終了判定の組み合わせで最初や最後のデータが処理されないこともあるので注意

プッシュ=PUSH - 実効前のSPから1を引き、SPで指定されたアドレスに実効アドレスを格納する(番地をスタックにプッシュ)
- PUSH A - 実行前のSPから1を引いてそのアドレスにラベルAの実効アドレスを入れる
- PUSH 3 - 実行前のSPから1を引いてそのアドレスに3を入れる
- PUSH 0, GR1 - 実行前のSPから1を引き、そのアドレス(SP-1番地)にGR1の内容を入れる

ポップ=POP - SPのアドレスからデータを取り出し、SPに1を加える(スタックから番地をポップ)
- POP GR0 - スタック最上段のデータをGR0に引っ張り出してSPに1を加える

コール=CALL - プログラムレジスタ(PR)(CALL命令の次の命令の番地)をスタックに入れてサブルーチンに制御を移す
- CALL SUB - SPから1を引いてスタックに戻り番地(CALLの次の命令の実行アドレス)を格納し、サブルーチンSUBに制御を移す

リターン=RET(RETurn from subroutine) - スタックの最上段に格納された、つまり最後にコールしたルーチンに制御を戻す
- スタックの最上段に戻り番地を格納してから使わないといけない。サブルーチンにスタックでデータを渡す場合、サブルーチンがスタックの最上段に戻り番地を格納しちゃってるのでそれを退避する必要がある
- RET - スタック最上段の実効アドレスをPRに格納して、制御をメインルーチンの戻り番地に移す

スーパバイザコール=SVC(SuperVisor Call) - 実効アドレスをOSに渡して処理してもらう
- IN(入力装置から文字を入れる)やOUT(出力装置にデータを出す)の前に指示する

ノーオペレーション=NOP(No OPeration) - 何もしない

マクロ命令
- キーボードやファイルから1レコードの文字データを読み込むIN命令、ディスプレイに1レコードとして文字データを出力するOUT命令、GR0を除く全レジスタをスタックに格納するRPUSH命令、スタックの最上段の内容を一気にGR7,GR6,...,GR1と取り出すRPOP命令がある

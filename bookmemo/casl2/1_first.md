基礎
- シミュレータでトレースは大事。ブラウザ版がiPadでも使えるので使おう
- 覚醒に到達すればいける！
- CPUは機械語を解読して実行する。CPU内部のレジスタに主記憶装置からデータを読み込む
- 主記憶とCPUの間でプログラムとデータがバスを通って行き来する
- CPUが理解できるのは回路がつながっているかいないか=機械語の0か1
- アセンブラ言語と機械語は1対1。要するにCPU=コンピュータの中の人とのタメ口会話がアセンブラ
- アセンブラはアセンブラ言語から機械語に翻訳するもののこと

CPUと主記憶装置
- 主記憶装置（メモリのこと）は1個の絶対アドレス（番地）内に16ビット（16個）の語（0か1）を格納できる。アドレスをCPUが指定してデータやプログラムを呼び出す
- ちなみにアドレスも機械語で表現するので最大値は(1111 1111 1111 1111)2=(65535)10。昔のゲームでよく出てくるこの数字はゲーム機=コンピュータの中の人（CPU）的にキリがいいのである
- 汎用レジスタはCPUの内部にある処理装置のこと。RPGでアイテムは装備しないと使えないように、データもCPUのレジスタ内に入れてから出ないと処理できない
- スタックはアドレスを意識せずデータが出し入れできる手記屋内の一部分のことで（筒みたいなのにデータを積み上げる感じ）、CPU内の16ビットのレジスタ（スタックポインタ）が最上段のアドレス（どこまで積まれたか）を記憶する
- フラグレジスタは「事象が成立したか」を記憶する3ビットの特殊なレジスタ。これを利用してプログラムを分岐させることができる
- プログラムレジスタは次の命令が格納された主記憶のアドレスを保持する。これが指し示すアドレスを引っ張ってきてデコーダに渡す
    - プログラムも主記憶内にある（あたりまえ体操）
- デコーダはCPU内の命令解読機構。だいたい以下みたいな感じでデコード（解読）＞実行していく
    1. 主記憶に次に読むプログラムコードをプログラムレジスタが伝える
    2. 主記憶はアドレスが指した命令をデコーダに渡す（フェッチ）
    3. プログラムレジスタに命令の長さを加える
    4. デコーダが解読（デコード）する
    5. CPUが機械語に基づき命令を実行する

文字コード
- 文字も機械語（文字コード）で表される。かっこいいターミナルもかっこいいフォントデータをターミナル側で文字コード指定しかっこよくしている

プログラムの文法
- ラベルは命令のアドレスを他命令やプログラムに教えるための名前（プログラムも主記憶に入ってるから）。8文字までで、先頭文字は必ず英大文字、以後の文字は英題文字または数字だけが使える
- 命令コードは「アセンブラ命令」「マクロ命令」「機械語命令」のいずれかの命令種類を書く
- オペランドは命令の内容を書く
- コメントはプログラムの解説を書く。記述形式は自由

アセンブラ命令
- アセンブラ（翻訳システム）に指示する命令。START、END、DS、DCの4種類
- アセンブラ命令はデコードせずとも実行できるので最初に実行される（あたりまえ体操）

- START命令はプログラムの先頭をアセンブラに教える。なので翻訳されない。またラベルは必須
- START命令の横にラベルを指定することもでき、その場合はラベルのところから処理が始まる。ラベルは他の命令の入り口名としても参照できる

- END命令はプログラムの終わりを教える
- これ自体は実行される命令ではないのでRET（処理終了）命令を忘れるとアセンブラ命令を無理やり機械語に翻訳した挙句命令じゃないところまでコードと誤認して無理やり実行し止まらなくなるので気をつけろ
- 余談…これをゲームで悪用したのがいわゆる任意コード実行（TASさんがやるあれ）。要はハッキング

- DS命令は指定語数文の領域を指定ラベルに紐づけて主記憶に確保する。ラベルだけつけて領域を確保しないこともできる
- この領域をテーブルや配列と呼ぶ。ラベルを指定したりラベルからインデックスレジスタを使って引っ張ってきたりする

- DC命令は指定定数を定数の個数分ラベルに紐づけて主記憶上に確保する
- 16進定数は4桁指定で先頭にシャープをつける
- 文字定数はアポストロフィで挟んで指定する
- アドレスも定数にでき、間接アドレス指定やジャンプテーブルなど高度テクニックに使われる

その他の命令
- マクロ命令は機械語命令を組み合わせた自作命令のこと
- 機械語命令は翻訳されて実行される命令のこと

機械語の形式
- 1語命令は「命令コードが8ビット」「レジスタ指定1が4ビット、指定2が4ビット」
- 2語命令は「命令コードが8ビット」「レジスタ指定が4ビット」「インデックスレジスタ指定が4ビット」「アドレスが16ビット」

ADDA      GR1, GR2
0010 0100 0001 0010

SUBA      GR2       100
0010 0001 0010 0000 0000 0000 0110 0100
					 ↑インデックスレジスタを使わないことを示す

- 実際のプログラムは絶対アドレスでなくラベルを指定するが最終的にはアドレスに変換される

AND GR0,DATA,GR2 
0011 0100 0000 0010 0000 0000 0001 0100
AND = 最初の8ビット
使うレジスタ（GR0） = 12〜16ビットめ
インデックスアドレス（GR2） = 17〜20ビットめ
DATAラベルの指すアドレス = 残り16ビット

- CASLIIのプログラムにおいてラベルのアドレスがどの番地かは主記憶のどこでもいい（リロケータブル）のでプログラミング上では気にしなくていい
- だが主記憶のアドレスと中身の紐付けは常に重要。主記憶を制するものはアセンブラを制す！

インデックスレジスタとアドレス修飾
- 汎用レジスタGR0〜GR7のうちGR1〜GR7はインデックスレジスタとして使える。インデックスレジスタは機械語命令のアドレスを修飾するのに使う
- アドレス修飾は命令アドレスにレジスタ内容を加算して実効アドレスを作ることで、ラベルから離れたアドレスを相対指定して引っ張ってくるときに使う
- インデックスレジスタによって示される値を相対アドレスといい、どれだけ離れているかを変位という
- ちなみにGR0がインデックスレジスタにできないのは「0000を『インデックスレジスタ無指定を示す命令』に割り当ててしまったから」である
